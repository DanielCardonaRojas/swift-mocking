
import SwiftSyntax
import SwiftSyntaxBuilder

/// Provides functionality for generating the conformance of the mock struct.
extension MockableGenerator {
    /// Generates a computed `instance` property that synthesizes a protocol conformance by building a witness value for that protocol
    /// and using the Synthesized type generated by the `Witness` package.
    ///
    /// For a protocol `PricingService`, this generates:
    /// ```swift
    /// var instance: Witness.Synthesized {
    ///     .init(context: self, witness: .init(price: adapt(\\\.price)))
    /// }
    /// ```
    ///
    /// - Parameter protocolDecl: The `ProtocolDeclSyntax` to generate the property for.
    /// - Returns: A `DeclSyntax` representing the computed `instance` property.
    static func makeInstanceComputedProperty(protocolDecl: ProtocolDeclSyntax) -> DeclSyntax {
        let returnType = IdentifierTypeSyntax(name: .identifier("Conformance"))
        let contextArgument = DeclReferenceExprSyntax(baseName: .keyword(.`self`))

        let outerInitArguments = LabeledExprListSyntax {
            LabeledExprSyntax(
                label: "context",
                colon: .colonToken(trailingTrivia: .space),
                expression: contextArgument
            )
            LabeledExprSyntax(
                label: "strategy",
                colon: .colonToken(trailingTrivia: .space),
                expression: ExprSyntax(literal: "mocking")
            )
        }

        let outerInit = FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(name: .keyword(.`init`)),
            leftParen: .leftParenToken(),
            arguments: outerInitArguments,
            rightParen: .rightParenToken()
        )

        let instanceVar = VariableDeclSyntax(
            modifiers: .init([
                DeclModifierSyntax(name: .keyword(.lazy))
            ]),
            bindingSpecifier: .keyword(.var),
            bindings: [
                PatternBindingSyntax(
                    pattern: IdentifierPatternSyntax(identifier: .identifier("instance")),
                    typeAnnotation: TypeAnnotationSyntax(type: returnType),
                    initializer: .init(value: ExprSyntax(outerInit))
                )
            ]
        )

        return DeclSyntax(instanceVar)
    }

    static func makeWitnessProperty(protocolDecl: ProtocolDeclSyntax) -> DeclSyntax {
        let instanceVar = makeWitnessVar(protocolDecl: protocolDecl)
        return DeclSyntax(instanceVar)
    }

    private static func makeWitnessVar(protocolDecl: ProtocolDeclSyntax, modifiers: DeclModifierListSyntax = []) -> VariableDeclSyntax {
        let returnType = IdentifierTypeSyntax(name: .identifier("Witness"))
        return VariableDeclSyntax(
            modifiers: modifiers,
            bindingSpecifier: .keyword(.var),
            bindings: [
                PatternBindingSyntax(
                    pattern: IdentifierPatternSyntax(identifier: .identifier("witness")),
                    typeAnnotation: TypeAnnotationSyntax(type: returnType),
                    accessorBlock: AccessorBlockSyntax(accessors: .getter( CodeBlockItemListSyntax {
                        makeWitnessInit(protocolDecl: protocolDecl)
                    }))
                )
            ]
        )
    }


    static func makeWitnessInit(protocolDecl: ProtocolDeclSyntax) -> FunctionCallExprSyntax {
        let funcDecls = protocolDecl.memberBlock.members.compactMap { $0.decl.as(FunctionDeclSyntax.self) }
        var functionNames = [String: Int]()
        let witnessArguments = LabeledExprListSyntax {
            for funcDecl in funcDecls {
                let funcName = funcDecl.name.text
                let spyPropertyName = spyPropertyName(for: funcDecl, functionNames: &functionNames)
                let effectType = getFunctionEffectType(funcDecl)
                let isStatic = funcDecl.modifiers.contains(where: { $0.isStatic })

                let declReferenceExpr = DeclReferenceExprSyntax(baseName: .identifier("adapt\(effectType)"))
                let argList = LabeledExprListSyntax {
                    if !isStatic {
                        LabeledExprSyntax(
                            expression: MemberAccessExprSyntax(
                                base: SuperExprSyntax(),
                                name: .identifier(spyPropertyName)
                            )
                        )
                    } else {
                        LabeledExprSyntax(
                            expression: MemberAccessExprSyntax(
                                base: DeclReferenceExprSyntax(baseName: .identifier("Super")),
                                name: .identifier(spyPropertyName)
                            )
                        )

                    }
                }

                let adaptCall = FunctionCallExprSyntax(
                    calledExpression: declReferenceExpr,
                    leftParen: .leftParenToken(),
                    arguments: argList,
                    rightParen: .rightParenToken()
                )
                let staticAdaptCall = FunctionCallExprSyntax(
                    calledExpression: MemberAccessExprSyntax(
                        base: DeclReferenceExprSyntax(baseName: .keyword(.`Self`)),
                        name: .identifier("adapt\(effectType)")
                    ),
                    leftParen: .leftParenToken(),
                    arguments: argList,
                    rightParen: .rightParenToken()
                )

                LabeledExprSyntax(
                    leadingTrivia: .newline,
                    label: .identifier(funcName),
                    colon: .colonToken(trailingTrivia: .space),
                    expression: isStatic ? staticAdaptCall : adaptCall
                )
            }
        }
        return FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(
                name: .keyword(.`init`)
            ),
            leftParen: .leftParenToken(),
            arguments: witnessArguments,
            rightParen: .rightParenToken(leadingTrivia: .newline)
        )
    }
}



import SwiftSyntax
import SwiftSyntaxBuilder

/// Provides functionality for generating the conformance of the mock struct.
extension MockableGenerator {
    /// Generates a computed `instance` property that synthesizes a protocol conformance by building a witness value for that protocol
    /// and using the Synthesized type generated by the `Witness` package.
    ///
    /// For a protocol `PricingService`, this generates:
    /// ```swift
    /// var instance: Witness.Synthesized {
    ///     .init(context: self, witness: .init(price: adapt(\\\.price)))
    /// }
    /// ```
    ///
    /// - Parameter protocolDecl: The `ProtocolDeclSyntax` to generate the property for.
    /// - Returns: A `DeclSyntax` representing the computed `instance` property.
    static func makeInstanceComputedProperty(protocolDecl: ProtocolDeclSyntax) -> DeclSyntax {
        let mockWitnessTypeName = "Witness"

        let returnType = MemberTypeSyntax(
            baseType: IdentifierTypeSyntax(name: .identifier(mockWitnessTypeName)),
            name: .identifier("Synthesized")
        )

        let funcDecls = protocolDecl.memberBlock.members.compactMap { $0.decl.as(FunctionDeclSyntax.self) }

        let witnessArguments = LabeledExprListSyntax {
            for funcDecl in funcDecls {
                let funcName = funcDecl.name.text

                let adaptCall = FunctionCallExprSyntax(
                    callee: DeclReferenceExprSyntax(baseName: .identifier("adapt"))
                ) {
                    LabeledExprSyntax(
                        expression: KeyPathExprSyntax(
                            backslash: .backslashToken(),
                            components: [
                                KeyPathComponentSyntax(
                                    period: .periodToken(),
                                    component: .property(
                                        .init(declName: DeclReferenceExprSyntax(baseName: .identifier(funcName)))
                                    )
                                )
                            ]
                        )
                    )
                }

                LabeledExprSyntax(
                    label: .identifier(funcName),
                    colon: .colonToken(trailingTrivia: .space),
                    expression: adaptCall
                )
            }
        }

        let witnessInit = FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(name: .keyword(.`init`)),
            leftParen: .leftParenToken(),
            arguments: witnessArguments,
            rightParen: .rightParenToken()
        )

        let contextArgument = DeclReferenceExprSyntax(baseName: .keyword(.`self`))

        let outerInitArguments = LabeledExprListSyntax {
            LabeledExprSyntax(label: "context", colon: .colonToken(trailingTrivia: .space), expression: contextArgument)
            LabeledExprSyntax(label: "witness", colon: .colonToken(trailingTrivia: .space), expression: witnessInit)
        }

        let outerInit = FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(name: .keyword(.`init`)),
            leftParen: .leftParenToken(),
            arguments: outerInitArguments,
            rightParen: .rightParenToken()
        )

        let getterBody = CodeBlockSyntax(
            statements: [
                CodeBlockItemSyntax(item: .expr(ExprSyntax(outerInit)))
            ]
        )

        let instanceVar = VariableDeclSyntax(
            bindingSpecifier: .keyword(.var),
            bindings: [
                PatternBindingSyntax(
                    pattern: IdentifierPatternSyntax(identifier: .identifier("instance")),
                    typeAnnotation: TypeAnnotationSyntax(type: returnType),
                    accessorBlock: AccessorBlockSyntax(accessors: .getter(getterBody.statements))
                )
            ]
        )

        return DeclSyntax(instanceVar)
    }
}


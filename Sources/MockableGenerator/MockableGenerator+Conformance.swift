
import SwiftSyntax
import SwiftSyntaxBuilder

/// Provides functionality for generating the conformance of the mock struct.
extension MockableGenerator {
    /// Generates a computed `instance` property that synthesizes a protocol conformance by building a witness value for that protocol
    /// and using the Synthesized type generated by the `Witness` package.
    ///
    /// For a protocol `PricingService`, this generates:
    /// ```swift
    /// var instance: Witness.Synthesized {
    ///     .init(context: self, witness: .init(price: adapt(\\\.price)))
    /// }
    /// ```
    ///
    /// - Parameter protocolDecl: The `ProtocolDeclSyntax` to generate the property for.
    /// - Returns: A `DeclSyntax` representing the computed `instance` property.
    static func makeInstanceComputedProperty(protocolDecl: ProtocolDeclSyntax) -> DeclSyntax {
        let returnType = IdentifierTypeSyntax(name: .identifier("Conformance"))
        let contextArgument = DeclReferenceExprSyntax(baseName: .keyword(.`self`))

        let outerInitArguments = LabeledExprListSyntax {
            LabeledExprSyntax(
                label: "context",
                colon: .colonToken(trailingTrivia: .space),
                expression: contextArgument
            )
            LabeledExprSyntax(
                label: "strategy",
                colon: .colonToken(trailingTrivia: .space),
                expression: ExprSyntax(literal: "mocking")
            )
        }

        let outerInit = FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(name: .keyword(.`init`)),
            leftParen: .leftParenToken(),
            arguments: outerInitArguments,
            rightParen: .rightParenToken()
        )

        let getterBody = CodeBlockSyntax(
            statements: [
                CodeBlockItemSyntax(stringLiteral: "witness.register(strategy: \"mocking\")"),
                CodeBlockItemSyntax(item: .stmt(StmtSyntax(ReturnStmtSyntax(expression: ExprSyntax(outerInit))))),
            ]
        )

        let instanceVar = VariableDeclSyntax(
            bindingSpecifier: .keyword(.var),
            bindings: [
                PatternBindingSyntax(
                    pattern: IdentifierPatternSyntax(identifier: .identifier("instance")),
                    typeAnnotation: TypeAnnotationSyntax(type: returnType),
                    accessorBlock: AccessorBlockSyntax(accessors: .getter(getterBody.statements))
                )
            ]
        )

        return DeclSyntax(instanceVar)
    }

    static func makeWitnessProperty(protocolDecl: ProtocolDeclSyntax, modifiers: DeclModifierListSyntax = []) -> DeclSyntax {
        let returnType = IdentifierTypeSyntax(name: .identifier("Witness"))
        let instanceVar = VariableDeclSyntax(
            modifiers: modifiers,
            bindingSpecifier: .keyword(.var),
            bindings: [
                PatternBindingSyntax(
                    pattern: IdentifierPatternSyntax(identifier: .identifier("witness")),
                    typeAnnotation: TypeAnnotationSyntax(type: returnType),
                    accessorBlock: AccessorBlockSyntax(accessors: .getter( CodeBlockItemListSyntax {
                        makeWitnessInit(protocolDecl: protocolDecl)
                    }))
                )
            ]
        )
        return DeclSyntax(instanceVar)
    }


    static func makeWitnessInit(protocolDecl: ProtocolDeclSyntax) -> FunctionCallExprSyntax {
        let funcDecls = protocolDecl.memberBlock.members.compactMap { $0.decl.as(FunctionDeclSyntax.self) }
        var functionNames = [String: Int]()
        let witnessArguments = LabeledExprListSyntax {
            for funcDecl in funcDecls {
                let funcName = funcDecl.name.text
                let spyPropertyName = spyPropertyName(for: funcDecl, functionNames: &functionNames)
                let effectType = getFunctionEffectType(funcDecl)

                let adaptCall = FunctionCallExprSyntax(
                    callee: DeclReferenceExprSyntax(baseName: .identifier("adapt\(effectType)"))
                ) {
                    LabeledExprSyntax(
                        expression: DeclReferenceExprSyntax(baseName: .identifier("self"))
                    )
                    LabeledExprSyntax(
                        expression: MemberAccessExprSyntax(
                            base: SuperExprSyntax(),
                            name: .identifier(spyPropertyName)
                        )
                    )
                }

                LabeledExprSyntax(
                    leadingTrivia: .newline,
                    label: .identifier(funcName),
                    colon: .colonToken(trailingTrivia: .space),
                    expression: adaptCall
                )
            }
        }
        return FunctionCallExprSyntax(
            calledExpression: MemberAccessExprSyntax(name: .keyword(.`init`)),
            leftParen: .leftParenToken(),
            arguments: witnessArguments,
            rightParen: .rightParenToken(leadingTrivia: .newline)
        )
    }
}


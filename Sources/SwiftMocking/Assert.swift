//
//  Assert.swift
//  Mockable
//
//  Created by Daniel Cardona on 6/07/25.
//

/// A class used for verifying interactions with a ``Spy``.
///
/// You typically obtain an `Assert` instance by calling the `verify(_:)` method on a `XCTestCase`.
///
/// ### Usage Example:
///
/// ```swift
/// protocol MyService {
///     func doSomething(value: String)
///     func calculate(a: Int, b: Int) throws -> Int
/// }
///
/// // Assuming MyServiceMock is generated by @Mockable macro
/// let mock = MyServiceMock()
/// let spy = mock.context // Access the spy instance
///
/// // Perform some actions that interact with the mock
/// _ = try? mock.calculate(a: 1, b: 2)
/// mock.doSomething(value: "test")
///
/// // Verify that 'doSomething' was called exactly once with "test"
/// verify(spy.doSomething(value: .equal("test"))).called(1)
///
/// // Verify that 'calculate' was called with any integers
/// verify(spy.calculate(a: .any, b: .any)).called()
///
/// // Verify that 'calculate' threw an error
/// verify(spy.calculate(a: .any, b: .any)).throws()
/// ```
public class Assert<each Input, Eff: Effect, Output> {
    var invocationMatcher: InvocationMatcher<repeat each Input>?
    unowned var spy: Spy<repeat each Input, Eff, Output>
    
    /// Initializes an `Assert` instance.
    /// - Parameters:
    ///   - invocationMatcher: An optional ``InvocationMatcher`` to filter which invocations to assert on. If `nil`, asserts on all invocations.
    ///   - spy: The ``Spy`` instance to assert against.
    public init(
        invocationMatcher: InvocationMatcher<repeat each Input>? = nil,
        spy: Spy<repeat each Input, Eff, Output>
    ) {
        self.invocationMatcher = invocationMatcher
        self.spy = spy
    }

    /// Asserts that the spy's method was called a certain number of times.
    /// - Parameter matcher: An optional ``ArgMatcher`` for `Int` to specify the expected call count. If `nil`, asserts that the method was called at least once.
    /// - Throws: ``MockingError/unfulfilledCallCount(_:)`` if the actual call count does not satisfy the matcher.
    public func assert(_ matcher: ArgMatcher<Int>?) throws {
        let countMatcher = matcher ?? .greaterThan(.zero)
        let count = if let invocationMatcher { spy.invocationCount(matching: invocationMatcher) } else { spy.invocations.count }
        if !countMatcher(count) {
            throw MockingError.unfulfilledCallCount(count)
        }
    }

    /// Asserts that the spy's method threw an error.
    /// - Parameter errorMatcher: An optional ``ArgMatcher`` for `Error` to specify the expected error. If `nil`, asserts that any error was thrown.
    /// - Throws:
    ///   - ``MockingError/didNotThrow`` if no error was thrown.
    ///   - ``MockingError/didNotMatchThrown(_:)`` if an `errorMatcher` is provided and no thrown error matches it.
    public func doesThrow(_ errorMatcher: ArgMatcher<any Error>? = nil) throws {
        var errors = [any Error]()
        for invocation in spy.invocations {
            for stub in spy.stubs {
                // Is there is no programmed `Return` for this stub don't even bother trying to match
                guard let stubbedReturn = stub.returnValue(for: invocation) else {
                    continue
                }

                if stub.invocationMatcher.isMatchedBy(invocation) { // Found a candidate

                    if let invocationMatcher {
                        // If an invocation matcher is non nil than it also needs to match
                        if invocationMatcher.isMatchedBy(invocation) {
                            try Self.collectErrors(stubbedReturn, errors: &errors)
                        }
                    } else {
                        try Self.collectErrors(stubbedReturn, errors: &errors)
                    }
                }
            }
        }

        if errors.isEmpty {
            throw MockingError.didNotThrow
        }

        if let errorMatcher, !errors.contains(where: errorMatcher.callAsFunction) {
            throw MockingError.didNotMatchThrown(errors)
        }

        return
    }

    private static func collectErrors<O>(_ result: Return<O>, errors: inout [any Error]) throws {
        do {
            _ = try result.get()
        } catch {
            errors.append(error)
        }
    }
}

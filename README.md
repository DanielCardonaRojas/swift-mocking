# Mockable

Mockable is a modern, type-safe mocking library for Swift that leverages the power of parameter packs and protocol witnesses to provide a clean, readable, and efficient mocking experience.

## Key Features

*   **Type-Safe Mocking:** By using parameter packs, Mockable ensures that your mocks are always in sync with your protocol definitions. This eliminates a common source of runtime errors and makes your tests more robust.
*   **No Preprocessor Macros:** Unlike other mocking libraries, Mockable does not rely on `#if DEBUG` or other preprocessor macros. Instead, it uses a separate package to generate a protocol witness via the `Witnessed` macro. This means that you only generate the code you need, where you need it.
*   **Clean, Readable API:** Mockable provides a Mockito-style API that is easy to read and write. This makes your tests more expressive and easier to maintain.
*   **Target-Specific Code Generation:** Mockable generates useful code for each target. For your main target, it generates a protocol witness. For your test target, it synthesizes a conformance to the protocol by creating a mock object that builds a witness and provides the correct context.
*   **Flexible Argument Matching:** Use powerful argument matchers like `.any`, `.equal`, or even create your own to specify exactly which invocations to stub or verify. Many matchers conform to `ExpressibleBy...Literal` protocols for a cleaner, more readable syntax. For example, instead of writing `verify(spy.price(.any)).called(.equal(2))`, you can simply write `verify(spy.price(.any)).called(2)`.

## How it Works

Mockable uses a two-pronged approach to mocking:

1.  **Protocol Witness Generation:** In your main target, you use the `@Mockable` macro to generate a protocol witness for your protocol. This witness is a struct that contains a function for each function in your protocol.

2.  **Mock Object Synthesis:** In your test target, you use the generated `Mock` struct to create a mock object. This mock object contains a `Spying` struct that allows you to stub and verify calls to your protocol's functions.

## Example

Here's an example of how to use Mockable to mock a `PricingService` protocol:

```swift
@Mockable
protocol PricingService {
    func price(_ item: String) -> Int
}
```

### Generated Code

The `@Mockable` macro generates the following code:

```swift
public struct PricingServiceMock {
    public struct Spying {
        let price = Spy<String, None, Int>()
        func price(with value: ArgMatcher<String>) -> Interaction<String, None, Int> {
            Interaction.init(matchers: value, spy: price)
        }
    }
    typealias PricingServiceMockWitness = PricingServiceWitness<Spying>
    static func new() -> PricingServiceMockWitness.Synthesized {
        .init(
            context: .init(),
            witness: .init(price: adapt(\.price))
        )
    }
}

// This would be generated by the Witnessed macro
struct PricingServiceWitness<A> {
    var price: (A, String) -> Int

    struct Synthesized: PricingService {
        let context: A
        let witness: PricingServiceWitness

        func price(_ item: String) -> Int {
            witness.price(context, item)
        }
    }
}
```

### Usage

In your tests, you can use the generated `PricingServiceMock` to create a mock object and stub its functions.

Note the use of argument matchers like `.any` and how `called(2)` is used instead of `called(.equal(2))` thanks to `ExpressibleByIntegerLiteral` conformance.

```swift
import Mockable
import XCTest

final class MockitoTests: XCTestCase {
    func testMock() {
        let mock = PricingServiceMock.new()
        let spy = mock.context
        let store = Store(pricingService: mock)

        // Stub specific calls
        when(spy.price("apple")).thenReturn(13)
        when(spy.price("banana")).thenReturn(17)

        store.register("apple")
        store.register("banana")
        verify(spy.price(.any)).called(2)
        XCTAssertEqual(store.prices["apple"], 13)
        XCTAssertEqual(store.prices["banana"], 17)
    }
}
```
